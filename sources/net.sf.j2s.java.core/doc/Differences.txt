Notes
=====
updated 5/13/19 -- Mandarin U+79D8 reserved character; Missing Math methods; int and long
updated 5/10/19 -- adds a section on static issues in multi-(duplicate)-applet pages
updated 1/4/19 -- nio
updated 9/15/18 -- adds integer 1/0 == 0
updated 7/24/18 -- most classes replaced with https://github.com/frohoff/jdk8u-jdk
updated 6/5/17 -- reserved package name "window"
updated 3/11/17 -- myClass.getField
updated 3/7/17 -- overloading of JSplitPane.setDividerLocation
updated 3/2/17 -- more indication of classes not implemented (KeyListener)

=============================================================================
SwingJS and JDK 1.6+
=============================================================================

SwingJS implements a wide range of the Java language in JavaScript. The base
version for this implementation is Java 1.6. However, some classes were
implemented using older source code, and there are some missing methods.  

=================
DESIGN PHILOSOPHY
=================

The java2script/SwingJS design goal is to recreate a recognizable, easily debuggable
equivalent in JavaScript for as much of Java as practical. This means, for example, 
that one can call in JavaScript 

  new java.util.Hashtable()
  
and for all practical purposes it will appear that Java is running.


Applet vs. Application
----------------------

One of the very cool aspects of SwingJS is that it doesn't particularly matter if a browser-based
Java app is an "applet" or an "application". We don't need JNLP (Java Network Launch Protocol) 
because now we can just start up any Java application in a browser just as easily as any applet.
The associative array that passes information to the SwingJS applet (information that formerly
might have been part of the APPLET tag, such as width, height, and codebase, always referred to 
in our writing as "the Info array") allows the option to specify the JApplet/Applet "code" 
class or the application "main" class. Either one will run just fine.


Performance
-----------

Obviously, there are limitations. One is performance, but we have seen reproducible 
performance at 1/6 - 1/3 the speed of Java. Achieving this performance may require
some refactoring of the Java to make it more efficient in both Java and JavaScript. 
"for" loops need to be more carefully crafted; use of "new" and "instanceof" need to be
minimized in critical areas. Note that method overloading -- that is, the same method name
with different parameters, such as read(int) and read(byte) -- is no longer any problem. 
  

Threads
-------

Although there is only a single thread in JavaScript, meaning Thread.wait(), Thread.sleep(int) and 
Thread.notify() cannot be reproduced, we have found that this is not a serious limitation. 
For example, javax.swing.Timer() works perfectly in JavaScript. All it means is that threads 
that use sleep(int) or notify() must be refactored to allow Timer-like callbacks. That is, 
they must allow full exit and re-entry of Thread.run(), not the typical while/sleep motif. 

The key is to create a state-based run() that can be exited and re-entered in JavaScript.


Static fields
-------------

Final static primitive "constant" fields (String, boolean, int, etc.) such as 

static final int TEST = 3;
static final String MY_STRING = "my " + "string";

are converted to their primitive form automatically by the Eclipse Java compiler 
and do not appear in the JavaScript by their names. 

Other static fields are properties of their class and can be used as expected.

Note, however, that SwingJS runs all "Java" code on a page in a common "jvm" 
(like older versions of Java). So, like the older Java schema, the JavaScript 
equivalents of both applets and applications will share all of their static 
fields and methods. This includes java.lang.System. 

Basically, SwingJS implementations of Java run in a browser page-based sandbox 
instead of an applet-specific one.

In general, this is no problem. But if we are to implement pages with 
multiple applets present, we must be sure to only have static references 
that are "final" or specifically meant to be shared in a JavaScript 
environment only (since they will not be shared in Java).

A simple solution, if static non-constant references are needed, is to attach the 
field to Thread.currentThread.threadGroup(), which is an applet-specific reference.
Be sure, if you do this, that you use explicit setters and getters:

For example, 

private static String myvar;

...

public void setMyVar(String x) {
  ThreadGroup g = Thread.currentThread().threadGroup();
  /**
   * @j2sNative g._myvar = x;
   * 
   */
   {
     myvar = x;
   }
}

public String getMyVar() {
  ThreadGroup g = Thread.currentThread().threadGroup();
  /**
   * @j2sNative return g._myvar || null;
   * 
   */
   {
     return myvar;
   }
}
 
 in Java will get and set x the same in JavaScript and in Java. 
 
 
A convenient way to do this in general is to supply a singleton class with
explicitly private-only constructors and then refer to it in Java and in JavaScript
instead of using static field, referring to myclass.getIntance().xxx instead of 
myclass.xxx in Java (and JavaScript). 

This was done extensively in the Jalview project. See jalview.bin.Instance.


Modal Dialogs
-------------

Although true modal dialogs are not possible with only one thread, a functional equivalent -- 
asynchronous modal dialogs -- is relatively easy to set up. All the JOptionPane dialogs will
return PropertyChangeEvents to signal that they have been disposed of and containing the results. 
More on this later....


Native calls
------------

Native calls in Java are calls to operating system methods that are not in Java. JavaScript
has no access to these, of course, and they must all be replaced by JavaScript equivalents.
Fortunately, they are not common, and those that are present in Java (for example, in calculating
checksums in ZIP file creation) are at a low enough level that most developers do not utilize them
or do not even have access to them. All native calls in Java classes have been replaced by 
Java equivalents.


Swing GUI Peers and UIClasses
-----------------------------

One of the biggest adaptations introduced in SwingJS is in the area of the graphical 
user interface. The issue here is complex but workable. In Java there are two background 
concepts -- the Component "peer" (one per "heavy-weight" component, such as a Frame) and the 
component "uiClass" (one per component, such as JButton or JTextField).

Peers are native objects of the operating system. These are the virtual buttons and text areas
that the user is interacting with at a very base level. Their events are being passed on to 
Java or the browser by the operating system. UI classes provide a consistent "look and feel" 
for these native objects, rendering them onto the native window canvas and handling all 
user-generated events. They paint the borders, the backgrounds, the highlights, of every 
control you see in Java. There is one-to-one correspondence of Swing classes and UI classes. 
Setting the Look and Feel for a project amounts to selecting the directory from which to draw 
these UI classes. The UI classes can be found in the javax.swing.plaf ("platform look and feel") 
package.

Early on in the development of SwingJS, we decided not to fully reproduce the painfully detailed 
bit-by-bit painting of controls as is done in Java. Instead, we felt it was wiser to utilize the standard
HTML5 UI capabilities as much as possible, using DIV, and INPUT especially, with extensive use
of CSS and sometimes jQuery (menus, and sliders, for example). Thus, we have created a new 
set of UIs -- the "HTML5 Look and Feel". These classes can be found in swingjs.plaf. Besides being
more adaptable, this approach allows far more versatility to SwingJS developers, allowing them
to modify the GUI to suit their needs if desired.

In SwingJS, since we have no access to native peers except through the browser DOM,
it seemed logical to merge the peer and UI idea. So instead of having one peer per heavy-weight control and
one UI class instance for each control type, we just have one UI class instance per control, and
that UI class instance is what is being referred to when a "peer" is notified. 

In some ways this is a throw back to when all of Swing's components were subclasses of
specific AWT components such as Button and List. These "heavy-weight components" all had their 
own individual native peers and thus automatically took on the look and feel provided by the OS. 
Later Swing versions implemented full look and feel for all peers, leaving only JDialog, JFrame,
and a few other classes to have native peers. But in SwingJS we have again a 1:1 map of component
and UI class/peer instance.

The origin of most issues (read "bugs") in relation to the GUI will probably be found in the
swingjs.plaf JSxxxxUI.java code.

  
Swing-only Components -- no longer an issue
-------------------------------------------

Swing was introduced into Java well after the Java Abstract Window Toolkit (AWT) was well
established. As such, its designers chose to allow AWT controls such as Button and List to be used 
alongside their Swing counterparts JButton and JList. Reading the code, it is clear that this 
design choice posed a huge headache for Swing class developers. 

For SwingJS, we decided from the beginning NOT to allow this mixed-mode programming and 
instead to require that all components be Swing components. 

However, this is no longer an issue. All AWT components in SwingJS are now subclasses of 
javax.swing.JComponent. So far, we have found no problem with this.

 
The a2s Adapter Package
-----------------------

Originally, we thought that we would restrict ourselves to JApplets only. That is, only
Swing-based applets. But as we worked, we discovered that there are a lot of great 
applets out there that are pre-Swing pure-AWT java.applet.Applet applets. Our problem was 
that we also wanted it to be possible to quickly adapt these applets to JavaScript as well.
 
The solution turned out to be simple: Write a package (a2s) that recreates the interface for 
non-Swing components as subclasses of Swing components. Thus, a2s.Button subclasses javax.swing.JButton
but also accepts all of the methods of java.awt.Button. It's not perfect, and the ultimate 
solution is probably to just change java.awt.Xxxx itself to subclass javax.swing.JXxxx.
In any case, it works -- mostly. By adding the a2s package to a project and changing the include
statements to target a2s instead of java.awt, non-Swing applets can be easily converted to JavaScript.
Certainly there will be issues such as missing methods. It is all a work in progress.

All AWT components now subclass a2s components, which in turn subclass JComponet.



UNIMPLEMENTED CLASSES BY DESIGN
===============================

accessibility
security
serialization


TODO LIST FOR UNIMPLEMENTED CLASSES
===================================

JEditorPane (minimal implementation) - DONE 12/2018
JSplitPane - DONE 8/2018
JTabbedPane - DONE 10/2018

JTree 


MINOR ISSUES--required some rewriting/refactoring by Bob and Udo  
================================================================

Thread.currentThread() == dispatchThread


MINOR ISSUES--requiring some rewriting/refactoring outside of SwingJS  
=====================================================================


ArrayIndexOutOfBounds
java.awt.Color
native methods
javax.swing.JFileDialog
key focus
LookAndFeel
System.exit(0) does not stop all processes
list cell renderers must be JComponents
myClass.getField not implemented
"window" and other reserved JavaScript names


MAJOR ISSUES--for Bob and Udo within SwingJS
============================================

fonts
OS-dependent classes
AWT component peers


MAJOR ISSUES--to be resolved by implementers
============================================

fonts
specific AWT components not implemented
threads
modal dialogs
image loading
BigDecimal not fully implemented 
no format internationalization
no winding rules
text-related field implementation
Formatter/Regex limitations
integer 1/0 == Infinity

======================================================================== 

DISCUSS
=======

Table row/col sorter needs checking after removal of java.text.Collator references

I had to move all of SunHints class to RenderingHints, or the 
two classes could not be loaded. Shouldn't be a problem, I think. The sun classes are
not accessible anyway.

We now have jsjava.lang.Thread and jsjava.lang.ThreadGroup. These should be useful in
figuring out what we want to do with those. ThreadGroup in particular is interesting,
as it is used to key for AppContexts. We will see if that use useful or not.

========================================================================== 

//////////////////////////////////////////////////////////////////////////////

UNIMPLEMENTED CLASSES
=====================

accessibility
-------------

All Accessibility handling has been commented out to save the download footprint.
This removes the need for sun.misc.SharedSecrets


security
--------

All JavaScript security is handled by the browser natively. 
Thus, Java security checking is no longer necessary, and 
java.security.AccessController has been simplified to work without
native security checking.


serialization
-------------

All serialization has been removed. It was never very useful for Swing anyway, 
because one needs exactly the same Java version to save and restore serialized objects.


keyboard accelerators
---------------------

JMenu.setAccelerator() and JMenuItem.setAccelerator() hae not been implemented in SwingJS. 
Thus, menus cannot be opened just be typing CTRL-C or similar shortcuts.


MINOR ISSUES--required some rewriting/refactoring by Bob and Udo  
================================================================


Thread.currentThread() == dispatchThread
----------------------------------------

changed to JSToolkit.isDispatchThread()


MINOR ISSUES--requiring some rewriting/refactoring outside of SwingJS  
=====================================================================

primitive numerical types
-------------------------

Large integers will never roll over to negative ones. They will
just get bigger.

						int newLength = lineBuf.length * 2;
						/**
						 * @j2sIgnore
						 */
						{
							// never going to happen in JavaScript
							if (newLength < 0) {
								newLength = Integer.MAX_VALUE;
							}
						}


Because "-1" in JavaScript is not 0xFFFFFFFF one must take care to not compare a negative number with a 32-bit mask;

(b & 0xFF000000) == 0xFF000000

is true in Java for (int) b = -1, but is false in JavaScript, because 0xFF000000 is 4278190080, 
while (-1 & 0xFF000000) is, strangely enough, -16777216, and, in fact, 

(0xFF000000 & 0xFF000000) != 0xFF000000

because -16777216 is not 4278190080.

One must compare similar operations:

if ((b & 0xFF000000) == (0xFF000000 & 0xFF000000)) .....



ArrayIndexOutOfBounds
---------------------

You cannot intentionally throw an ArrayIndexOutOfBoundsException in JavaScript.
JavaScript will simply return "undefined", not throw an Exception.

ArrayIndexOutOutBoundsException cannot be trapped in JavaScript because 
it is a JavaScript Error, not a Java Exception. 

Solution is to change that catch to catch(Throwable e), 
which includes all JavaScript errors and is transpiled as "catch(e)"
 

java.awt.Color
--------------

ColorSpace: only "support" CS_sRGB

 -BH: This is a temporary edit just to get us started.


javax.swing.JFileDialog
-----------------------

Not implemented. HTML5 cannot expose a file directory structure


native methods
--------------

The J2S compiler ignores all static native method declarations.
Anything of this nature needs to be implemented in JavaScript if it is needed,
using j2sNative blocks:

/**
 * @j2sNative
 *
 */
 {
   // it is critical to remember to insert this { } phrasing, 
   // or the block will be ignored!
 }
 

key Focus
---------
- Less explicit key focus 
- handling (mostly done by Browser/HTML)
- no SwingUtilities.findFocusOwner
- focus traversal not implemented


LookAndFeel
-----------

SwingJS implements the native browser LookAndFeel. Token UIManager methods are
present but unimplemented; methods returning key bindings or other arrays return null.

Note that LookAndFeel determines canvas size in a Frame because diffent operating
systems (Mac OS vs Windows vs HTML5) will have different edge sizes on their frames. 


System.exit(0) does not stop all processes
------------------------------------------

Although System.ext(int) has been implemented in JavaScript, it may not stop all "threads."
Applications are responsible for shutting down prior to executing it. 


myClass.getField not implemented
--------------------------------

java.lang.reflect.Field is not implemented. You can get a field value very simply
using:

/**
 *@j2sNative
 *
 * return myClass[name]
 */   


"window" and other reserved JavaScript names
--------------------------------------------

No reserved top-level JavaScript name is allowed for a package name. So, for example, 
one must rename packages such as "window" or "document" to names such as "win" or "doc".

qualified field and method names
--------------------------------

In order to minimize the chance of added SwingJS field and method names colliding with
ones developers might use in subclassing Java classes, we have added U+79D8 (Mandarin "secrect") 
to the characaters already disrecommended by Java documentation ("$" and "_"). The only problem
would be if you use that character followed by certain English words in certain classes. For example
\u79D8canvas for JComponents (in java.awt.JSComponent) and \u79D8byte (in java.io.File).

missing Math methods
--------------------

A few java.lang.Math 

MAJOR ISSUES--for Bob and Udo within SwingJS
============================================

fonts
-----

Fonts and FontMetrics will all be handled in JavaScript. Font matching will 
not be exact, and composite (drawn) fonts will not be supported. 

Jmol handles calls such as font.getFontMetrics(g).stringWidth("xxx") by 
creating an off-page DOM image and querying its context. 
This will be done here as well.
 
 
OS-dependent classes
--------------------

Static classes such as:

   java.awt.Toolkit
   java.awt.GraphicsEnvironment
   
   
which are created using Class.forName
will be implemented as JavaScript classes in the swingjs package

AWTAccessor and  AwtContext need to be customized 

   
AWT component peers and component "ui" user interfaces
------------------------------------------------------

ComponentPeer is a class that represents a native AWT component.
Components with such peers are called "heavy-weight" components.
They are expected to do the dirty work of graphics drawing. 

Java Swing implements peers only for JApplet, JDialog, JFrame, and JWindow. 
References to such objects have been removed, but clearly there must be 
some connection to similar DOM objects, even for "light-weight" components. 


  
MAJOR ISSUES--to be resolved by implementers
============================================

fonts
-----

Glyph/composite/outline fonts are not supported
   

specific AWT components not implemented
---------------------------------------

all AWT components are now implemented as subclasses of Swing counterparts. 2019.02.13 BH


threads
-------

Thread locking and synchronization are not relevant to JavaScript.
Thus, anything requiring "notify.." or "waitFor.." could be a serious issue.
 
All threading must be "faked" in JavaScript. Specifically not available is:

  Thread.sleep()
  
javax.swing.AbstractButton#doClick(pressTime) will not work, as it requires Thread.sleep();
    
However, java.lang.Thread itself is implemented and used extensively. 

Methods thread.start() and thread.run() both work fine. 

For simple applications that use Thread.sleep() just to have a delay, as in a frame rate, for 
example, one can use javax.swing.Timer instead. That is fully implemented. 

Likewise, java.util.Timer can be replaced with no loss of performance with javax.Swing.Timer.
Note that java.util.TimerTask is implemented, but it can also be replaced by an implementation of Runnable.

task = new TimerTask(){....};
t = new java.util.Timer();
t.schedule(task, 0, 1);

becomes

task = new TimerTask(){....}; // or task = new Runnable() {...}
t = new javax.swing.Timer(1, new ActionListener() {
	@Override
	public void actionPerformed(ActionEvent e) {
		task.run();
	}
};
t.setInitialDelay(0); // not particularly necessary
t.start();

In addition, SwingJS provides swingjs.JSThread, which can be subclassed
if desired. This class allows simple 

  while(!interrupted()){
  	wait()
  	...
  }  

action through an asynchronous function run1(mode). For example:

	protected void run1(int mode) {
		try {
			while (true)
				switch (mode) {
				case INIT:
					// once-through stuff here
					mode = LOOP;
					break;
				case LOOP:
					if (!doDispatch || isInterrupted()) {
						mode = DONE;
					} else {
						Runnable r = new Runnable() {
							public void run() {
								// put the loop code here
							}
						};
						dispatchAndReturn(r);
						if (isJS)
							return;
					}
					break;
				// add more cases as needed
				case DONE:
					// finish up here
					if (isInterrupted())
						return;
					// or here
					break;
				}
		} finally {
			// stuff here to be executed after each loop in JS or at the end in Java
		}
	}

image loading
-------------
- All image loading in SwingJS is synchronous. A MediaTracker call will immediately return "complete".
  However, it still may take one system clock tick to fully load images. Thus, it is recommended that
  images be preloaded in the static block of the applet if it is necessary that they be available in init().

- Applet.getImage(path, name) will return null if the image does not exist. 

- BufferedImage: only "support" imageType RGB and ARGB
  -BH: This is a temporary edit, just to get us started. Certainly GRAY will be needed


no BigInteger; no BigDecimal
----------------------------

BigInteger if fully supported; BigDecimal is roughed in and not fully supported


no format internationalization
------------------------------

For now, just en for number and date formatters

no winding rules
----------------

  When filling a graphic, only nonzero winding rule is implemented in HTML5 Canvas2D.



text-related field implementation
---------------------------------

Text fields are:

JTextField   (JavaScript <input type="text">)
JTextArea    (JavaScript <textarea>;)
JTextPane    (JavaScript <div>; non-editing; TODO)
JEditorPane  NOT IMPLEMENTED

For the initial implementation, we don't implement infinite undo/redo, and the abstract 
document model is much less elaborate. Only PlainDocument (in the form of JSPlainDocument)
is implemented. 
The Document returned by JTextField.getDocument() is a javax.swing.text.Document.

all scrolling is handled by HTML5
javax.swing.AutoScroller is not implemented
public static methods .stop, .isRunning, .processMouseDragged require true Java threading
javax.swing.text.View and its subclasses are not implemented. 

The JS document model does not allow two text fields to address the same underlying document. 


Formatter/Regex limitations
---------------------------

java.util.regex.Matcher and Pattern use JavaScript's RegExp object rather than
the native Java object. These are not identical. Only flags /igm are supported.
Matcher.start(groupID) is not supported.

java.util.Formatter will function correctly for all standard %... patterns.

integer 1/0 == 0
----------------

1/0 in Java throws "java.lang.ArithmeticException: / by zero", but in JavaScript is just Infinity. 
 
 
